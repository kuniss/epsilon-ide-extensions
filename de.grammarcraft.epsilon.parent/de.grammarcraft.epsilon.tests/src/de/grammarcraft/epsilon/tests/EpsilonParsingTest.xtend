/*
 * generated by Xtext 2.20.0
 */
package de.grammarcraft.epsilon.tests

import com.google.inject.Inject
import de.grammarcraft.epsilon.epsilon.Specification
import java.io.File
import java.nio.file.Files
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(EpsilonInjectorProvider)
class EpsilonParsingTest {
	@Inject
	ParseHelper<Specification> parseHelper
	
	
	@Test
	def void parseSimpleExample() {
		val result = parseHelper.parse('''
			! simple example
			x = "a" | "b".
			(* some nested comment *)
			x <+ "a": x> : "a".
		''')
		assertNotNull(result)
		val errors = result.eResource.errors
		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}


// java.lang.AssertionError: Unexpected errors:
// 1 extraneous input '>' expecting ':'
// 1 mismatched input '<' expecting '>'
// 1 missing ':' at 'Code'
// 1 no viable alternative at input '>'
	@Test
	def void parseFormalParamsWithOutExplicitAffixType() {
		val result = parseHelper.parse('''
			OberonO <+ Code>: Module <Code>.
		''')
		assertNotNull(result)
		val errors = result.eResource.errors
		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}
	
	@Test
	def void parseRedcutedExample() {
		val result = parseHelper.parse('''
			! DeclAppl
			
			Tab = | id ";" Tab.

			DeclAppl <+ Tab: Tab> :
				<, Tab >
				{ <- Tab : Tab, + Tab1: Tab>
					"DECL" id < id > Find <id, Tab, "FALSE" >
					<id ";" Tab, Tab1 >
				| <- Tab : Tab, + Tab1: Tab>
					"APPL" id < id > Find <id, Tab, "TRUE" >
					<Tab, Tab1 >
				} <- Tab : Tab, + Tab: Tab> .
			
			x = "a" | "b".
			id* = x | id x.
			
			x <+ "a": x> : "a".
			x <+ "b": x> : "b".
			
			id* <+ id: id> :
				x < x >
				<x, id >
				{ <- id : id, + id1: id>
					x < x > <id x, id1 >
				} <- id : id, + id: id> .
				
			Bool = "TRUE" | "FALSE".
			
			Find <- id: id, - : Tab, + "FALSE": Bool>: .
			Find <- id: id, - id ";" Tab : Tab, + "TRUE": Bool>: .
			Find <- id: id, - #id ";" Tab : Tab, + Bool: Bool>:
				Find <id, Tab, Bool >.
		''')
		assertNotNull(result)
		val errors = result.eResource.errors
		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}
	
	@Test
	def void parseExample1() {
		val specFile = new File(class.getResource('example1.eps').file)
		val spec = Files.readAllLines(specFile.toPath).join('\n')
		val result = parseHelper.parse(spec)
		assertNotNull(result)
		val errors = result.eResource.errors
		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}
	
	@Test
	def void parseExample2() {
		val specFile = new File(class.getResource('example2.eps').file)
		val spec = Files.readAllLines(specFile.toPath).join('\n')
		val result = parseHelper.parse(spec)
		assertNotNull(result)
		val errors = result.eResource.errors
		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}
	
	@Test
	def void parseOberon0Spec() {
		val obern0SpecFile = new File(class.getResource('oberon0.eps').file)
		val oberon0Spec = Files.readAllLines(obern0SpecFile.toPath).join('\n')
		val result = parseHelper.parse(oberon0Spec)
		assertNotNull(result)
		val errors = result.eResource.errors
		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}

}
